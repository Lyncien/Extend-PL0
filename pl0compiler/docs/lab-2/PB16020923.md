## 完成任务情况

1. 本人先完成了program, program_block, var_declaration, const_declaration, statemen, intable函数的编写，并建立了错误信息数组，添加了部分错误信息。
2. 其后赵敏帆同学完成了condItion, expression, term, factor 函数的编写，并添加了部分错误信息。
3. 本人继续完善上面函数的部分细节，继续添加部分错误信息，然后实现了输出语法树的功能，printtreenode1函数打印终结符，printtreenode2函数打印非终结符。
4. 本人继续实现了错误恢复，在遇到错误时尽量继续分析，但效果不太好。在每个函数的结束时，判断下一个token是否在当前非终结符的follow集合中，如果不是，则不断获取下一个token，直到在follow集合中或者文件结束。
5. 魏天一同学测试了各个example文件。
6. 赵敏帆同学修复了level相关问题和部分错误恢复问题。

## 遇到问题

#### 问题描述

测试 test_err.pl文件时，提示发现非法字符`'`

#### 具体细节

之前词法分析时，遇到非法字符就会返回错误，但没有考虑到在注释中是可以有任意字符的。

#### 解决问题概述

修改判断条件，遇到非法字符时，如果当前state是`IN_BLOCKCOMMENTS`或者`IN_LINECOMMENTS`，就不做操作，保持状态不变

#### 经验教训

要考虑仔细

------

#### 问题描述

id的level相关的问题

#### 具体细节

之前查id的table时仅仅判断该名字是否存在于表中，这样会忽略了id的作用域，外层引用内层声明的id这种错误就不会被检测出来。

#### 解决问题概述

在table中查询var和procedure声明的id时，只有当前的所处level大于等于id的level才认为id时声明过的，并且返回的index对应的id的level应该时最接近当前level的，这样才能处理内层外层都声明了同一个名称的id的情况。

#### 经验教训

要考虑仔细

## 感想与不足

1. 每个非终结符对应函数的实现都是多个判断语句的并列和嵌套，是否应该继续PL0Lex_get_token都要根据具体情况，无法统一处理，也只能应对一些常见情况，逐条编写错误信息，错误类型中有同类错误但没有合并在一起处理。
2. 打印语法树的函数穿插在各个函数中间，代码结构不够清晰。
3. 错误恢复只是简单跳过部分token直到下一个token在follow集中，没有进行更精确的判断，这样可能导致中间有一些错误被跳过。并且跳过部分token后，可能出现所在的层次和当前预期的不同，仅仅是token类型符合预期，这样会导致一些本来不该出现的错误。


